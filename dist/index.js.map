{"version":3,"file":"index.js","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/components/DragMove.tsx","../src/utils/ipfs_resolver.ts","../src/index.tsx"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import React, { useState } from \"react\";\n\n// @ts-expect-error\nexport default function DragMove(props) {\n  const {\n    onPointerDown,\n    onPointerUp,\n    onPointerMove,\n    onDragMove,\n    children,\n    style,\n    className\n  } = props;\n\n  const [isDragging, setIsDragging] = useState(false);\n\n  // @ts-expect-error\n  const handlePointerDown = (e) => {\n    setIsDragging(true);\n\n    onPointerDown(e);\n  };\n\n  // @ts-expect-error\n  const handlePointerUp = (e) => {\n    setIsDragging(false);\n\n    onPointerUp(e);\n  };\n\n  // @ts-expect-error\n  const handlePointerMove = (e) => {\n    if (isDragging) onDragMove(e);\n\n    onPointerMove(e);\n  };\n\n  return (\n    <div\n      onPointerDown={handlePointerDown}\n      onPointerUp={handlePointerUp}\n      onPointerMove={handlePointerMove}\n      style={style}\n      className={className}\n    >\n      {children}\n    </div>\n  );\n}\n\nDragMove.defaultProps = {\n  onPointerDown: () => {},\n  onPointerUp: () => {},\n  onPointerMove: () => {}\n};\n","export const resolveIpfs = (ipfsURI : String | string) : string=> {\n    if(ipfsURI.indexOf(\"ipfs://\") >= 0) {\n        let comps = ipfsURI.split(\"ipfs://\");\n        let uri = comps[1];\n        if(uri.indexOf(\"ipfs/\") >= 0) {\n            return `https://cloudflare-ipfs.com/${uri}`;\n        } else {\n            return `https://cloudflare-ipfs.com/ipfs/${uri}`;\n        }\n    } else {\n        return ipfsURI as string;\n    }\n};\n","import { Box, Container, makeStyles, Typography } from '@material-ui/core';\nimport AccountBalanceWalletIcon from '@material-ui/icons/AccountBalanceWallet';\nimport { SpeedDial, SpeedDialAction } from '@material-ui/lab';\nimport WalletConnectProvider from '@walletconnect/web3-provider';\nimport { ethers } from 'ethers';\nimport * as React from 'react';\nimport Web3 from 'web3';\nimport Web3Modal from \"web3modal\";\nimport DragMove from './components/DragMove';\nimport { InstalledApp } from './types/installedApp';\nimport abi from './utils/abi/Byoa.json';\nimport { resolveIpfs } from './utils/ipfs_resolver';\n\ninterface Props {\n  dataPipe?: {\n    data: any\n  }\n}\n\nconst byoaContractAddress = `0xD3CFd6dDd98b8245C849D0f845ddC0b6Ce2E01e3`;\nconst providerNetwork = `https://eth-ropsten.alchemyapi.io/v2/Uo717K-DDAxlSM5gXM-zgv678k0aMZH5`;\nconst jrpcProvider = new ethers.providers.JsonRpcProvider('https://eth-mainnet.alchemyapi.io/v2/Uo717K-DDAxlSM5gXM-zgv678k0aMZH5', 'mainnet');\n\nlet listeners: any = [];\n// @ts-expect-error\nwindow.byoa = {\n  context: {\n    target: {\n      hud: \"byoa-hud\"\n    },\n    ethers: ethers,\n    provider: ethers.getDefaultProvider('https://eth-mainnet.alchemyapi.io/v2/Uo717K-DDAxlSM5gXM-zgv678k0aMZH5'),\n    jrpcProvider: jrpcProvider,\n    addDataListener: (cb: any) => {\n      listeners.push(cb);\n    },\n    account: {\n      address: null\n    }\n  }\n};\n\nconst useStyles = makeStyles({\n  root: {\n    position: 'fixed',\n    top: 0,\n    left: 0,\n    minWidth: '100vw',\n    minHeight: '100vh',\n    background: 'rgba(50,0,0,0.00)',\n    pointerEvents: 'none'\n  },\n  speedDial: {\n    position: 'fixed',\n    bottom: 20,\n    right: 20,\n    zIndex: 1000000000\n  },\n  byoaButton: {\n\n  }\n});\n\nconst providerOptions = {\n  walletconnect: {\n    display: {\n      name: \"Mobile\"\n    },\n    package: WalletConnectProvider,\n    options: {\n      infuraId: \"6430aa46e9354b91bea44e464af71f7a\" // required\n    }\n  }\n};\n\nconst web3Modal = new Web3Modal({\n  network: providerNetwork, // optional\n  cacheProvider: true, // optional\n  disableInjectedProvider: false,\n  providerOptions // required\n});\n\nconst singletonByoaAppContainerId = \"byoa-singleton-container\";\n// postcondition: byoa app singleton container has been created and is appended to document body\nfunction getSingletonByoaAppContainer(): HTMLElement {\n  const j = document.getElementById(singletonByoaAppContainerId);\n  if (j !== null) return j;\n  const e = document.createElement(\"div\");\n  e.setAttribute(\"id\", singletonByoaAppContainerId);\n  e.style.position = 'absolute';\n  e.style.right = '1vw';\n  e.style.bottom = '1vh';\n  e.style.width = '24.1vw';\n  e.style.height = '38.2vh';\n  document.body.appendChild(e);\n  return e;\n}\n\nconst singletonByoaAppIframeId = \"byoa-singleton-iframe\";\n// postcondition: byoa app singleton iframe has been created, is a child of the passed container, and iframe src has been updated to passed src.\nfunction makeOrUpdateSingletonByoaAppIframe(container: HTMLElement, src: string): void {\n  const j = document.getElementById(singletonByoaAppIframeId);\n  if (j === null) {\n    const e = document.createElement(\"iframe\");\n    e.setAttribute(\"id\", singletonByoaAppIframeId);\n    e.setAttribute(\"src\", src);\n    e.style.width = '100%';\n    e.style.height = '100%';\n    container.appendChild(e);\n  } else {\n    j.setAttribute(\"src\", src);\n    container.appendChild(j);\n  }\n}\n\nexport const ByoaSDK = (props: Props) => {\n  const classes = useStyles();\n  const [translateDial, setTranslateDial] = React.useState({\n    x: 0,\n    y: 0\n  });\n  const [dialDirection, setDialDirection] = React.useState<\"left\" | \"right\" | \"up\" | \"down\" | undefined>(\"up\");\n  const [openDial, setOpenDial] = React.useState(false);\n  const [provider, setProvider] = React.useState<any>(null);\n  const [web3, setWeb3] = React.useState<any>(null);\n  const [accountAddress, setAccountAddress] = React.useState<String | null>(null);\n\n  const [installedApps, setInstalledApps] = React.useState<InstalledApp[]>([]);\n\n\n  const connectWallet = async () => {\n    try {\n      let p = provider;\n      if (p === null) {\n        p = await web3Modal.connect();\n        if (p === null) {\n          throw new Error('Unable to connect provider to modal');\n        }\n        p.on('accountsChanged', (e: any) => {\n          console.log(e);\n          disconnectWallet();\n        });\n        p.on(\"chainChanged\", (chainId: number) => {\n          console.log(\"chain \" + chainId);\n        });\n        setProvider(p);\n      }\n\n      let w3 = web3;\n      if (w3 === null) {\n        w3 = new Web3(p);\n        if (w3 === null) {\n          throw new Error('Unable to connect web3');\n        }\n        setWeb3(w3);\n      }\n\n      const accounts = await p.request({ method: 'eth_accounts' });\n      if (accounts.length > 0) {\n        setAccountAddress(accounts[0]);\n        setTimeout(async () => {\n          refreshMyApps(accounts[0]);\n        }, 2000);\n      }\n    } catch (error) {\n      console.log(error);\n      alert('Unable to connect wallet. Please try again.');\n    }\n  };\n\n  const disconnectWallet = async () => {\n    await web3Modal.clearCachedProvider();\n    setProvider(null);\n    setAccountAddress(null);\n  };\n\n  // TODO add ByoaAppMetadata type and parse this json into that type\n  const getTokenMetadata = async (uri: string): Promise<any> => {\n    const d = await fetch(resolveIpfs(uri));\n    const json = await d.json();\n    return json;\n  };\n\n  const refreshMyApps = async (addressHelper: String | undefined | null) => {\n    let w3 = new Web3(providerNetwork);\n    try {\n      // @ts-expect-error\n      let contract = new w3.eth.Contract(abi.abi, byoaContractAddress);\n\n      let myTokenIds = await contract.methods.walletOfOwner(accountAddress ? accountAddress : addressHelper).call();\n      // console.log(myTokenIds);\n\n      let appLUT: any = {};\n\n\n      let allInstalls: InstalledApp[] = [];\n      for (var i = 0; i < myTokenIds.length; i++) {\n        let tid = parseInt(myTokenIds[i]);\n        let appIdForToken = await contract.methods.getAppIdByTokenId(tid).call();\n        let directTokenURI = await contract.methods.tokenURI(tid).call();\n        let tokenMeta = await getTokenMetadata(directTokenURI);\n\n        if (appLUT[appIdForToken] !== null) {\n          let appDetails = await contract.methods.getAppDetailsById(parseInt(appIdForToken)).call();\n          appLUT[appIdForToken] =\n          {\n            id: appIdForToken,\n            name: appDetails[0],\n            description: appDetails[1],\n            tokenURI: appDetails[2],\n            owner: appDetails[3],\n            price: parseInt(appDetails[4]),\n            address: byoaContractAddress,\n            version: tokenMeta.version,\n          }\n        }\n\n        let ia: InstalledApp = {\n          id: tid,\n          tokenURI: directTokenURI,\n          app: appLUT[appIdForToken],\n          imageURI: tokenMeta.image,\n          byoaDetails: {\n            uri: tokenMeta.implementationURIs.browser,\n            target: 'iframe', // currently, byoa SDK only supports iframe apps. We are designing our strategy for plugins in the host app main javascript thread\n          }\n        }\n        allInstalls.push(ia);\n      }\n      // console.log(allInstalls)\n      setInstalledApps(allInstalls);\n\n    } catch (error) {\n      console.log(`Error fetching apps: ${error}`);\n    }\n  };\n\n  return (\n    <Box className={classes.root} id=\"byoa-hud\">\n      <Container className={classes.speedDial}>\n        <DragMove onDragMove={(e: any) => {\n          setTranslateDial({\n            x: translateDial.x + e.movementX,\n            y: translateDial.y + e.movementY\n          });\n          if (e.clientY < 200) {\n            if (dialDirection !== \"down\") setDialDirection(\"down\");\n          }\n          if (e.clientY > 200) {\n            if (dialDirection !== \"up\") setDialDirection(\"up\");\n          }\n        }}>\n          <SpeedDial\n            style={{\n              transform: `translateX(${translateDial.x}px) translateY(${translateDial.y}px)`\n            }}\n            ariaLabel=\"BYOA Speed Dial\"\n            hidden={false}\n            icon={<Typography className={classes.byoaButton}>RUN</Typography>}\n            open={openDial}\n            onOpen={() => {\n              setOpenDial(true);\n            }}\n            onClose={() => {\n              setOpenDial(false);\n            }}\n            onClick={() => {\n\n            }}\n            direction={dialDirection}\n          >\n            <SpeedDialAction\n              key={'sda-connect-wallet'}\n              icon={<AccountBalanceWalletIcon />}\n              tooltipTitle={'Connect Wallet'}\n              onClick={() => {\n                connectWallet();\n              }}\n            />\n            {installedApps.map((installedApp, i) => (\n              <SpeedDialAction\n                key={`sd-action-${installedApp.id}-${i}`}\n                icon={<img style={{ width: '40px', height: '40px' }} src={resolveIpfs(installedApp.imageURI)} />}\n                tooltipTitle={`${installedApp.app.name} ${installedApp.app.version}`}\n                onClick={() => {\n                  if (installedApp.byoaDetails.target === \"iframe\") { // TODO support javascript main thread plugins, right now it's just iframes as we focus on widgets and design our strategy for plugin security and communication with host apps\n                    const c = getSingletonByoaAppContainer();\n                    makeOrUpdateSingletonByoaAppIframe(c, resolveIpfs(installedApp.byoaDetails.uri));\n                  }\n                }}\n              />\n            ))}\n\n          </SpeedDial>\n        </DragMove>\n      </Container>\n    </Box>\n  )\n}\n"],"names":["DragMove","props","onPointerDown","onPointerUp","onPointerMove","onDragMove","children","style","className","useState","isDragging","setIsDragging","handlePointerDown","e","handlePointerUp","handlePointerMove","React","defaultProps","resolveIpfs","ipfsURI","indexOf","comps","split","uri","byoaContractAddress","providerNetwork","jrpcProvider","ethers","providers","JsonRpcProvider","window","byoa","context","target","hud","provider","getDefaultProvider","addDataListener","cb","listeners","account","address","useStyles","makeStyles","root","position","top","left","minWidth","minHeight","background","pointerEvents","speedDial","bottom","right","zIndex","byoaButton","providerOptions","walletconnect","display","name","WalletConnectProvider","options","infuraId","web3Modal","Web3Modal","network","cacheProvider","disableInjectedProvider","singletonByoaAppContainerId","getSingletonByoaAppContainer","j","document","getElementById","createElement","setAttribute","width","height","body","appendChild","singletonByoaAppIframeId","makeOrUpdateSingletonByoaAppIframe","container","src","ByoaSDK","classes","x","y","translateDial","setTranslateDial","dialDirection","setDialDirection","openDial","setOpenDial","setProvider","web3","setWeb3","accountAddress","setAccountAddress","installedApps","setInstalledApps","connectWallet","w3","Web3","p","Error","request","method","accounts","length","setTimeout","refreshMyApps","connect","on","console","log","disconnectWallet","chainId","error","alert","clearCachedProvider","getTokenMetadata","fetch","d","json","addressHelper","contract","eth","Contract","abi","methods","walletOfOwner","call","myTokenIds","allInstalls","appLUT","i","tid","parseInt","getAppIdByTokenId","appIdForToken","tokenURI","directTokenURI","tokenMeta","ia","id","app","imageURI","image","byoaDetails","implementationURIs","browser","push","getAppDetailsById","appDetails","description","owner","price","version","Box","Container","movementX","movementY","clientY","SpeedDial","transform","ariaLabel","hidden","icon","Typography","open","onOpen","onClose","onClick","direction","SpeedDialAction","key","AccountBalanceWalletIcon","tooltipTitle","map","installedApp","c"],"mappings":"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"}